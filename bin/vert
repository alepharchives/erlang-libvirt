#!/usr/bin/env escript

%%%
%%% Command line interface to libvirt
%%%
main(Opt) ->
    % load vert
    true = code:add_pathz(filename:dirname(escript:script_name())
        ++ "/../ebin"),
    call(Opt).

call(["capabilities" | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    rp(vert:virConnectGetCapabilities(Connect));

call(["console", Host]) ->
    io:setopts(standard_io, [binary]),

    {ok, FD} = serctl:open({fd, 0}),
    ok = serctl:tcsetattr(FD, tcsanow, serctl:mode(raw)),

    {ok, Ref} = vert_console:open(Host),
    spawn_link(fun() -> console_output(Ref) end),
    console_input(Ref);

call(["create", Host | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),

    {ok, Domain} = case file:read_file(Host) of
        {ok, XML} ->
            vert:virDomainDefineXML(Connect, XML);
        {error, enoent} ->
            domain(Connect, Host)
    end,

    rp(vert:virDomainCreate(Domain));

call(["ctl-alt-del", Host | Arg]) ->
    call(["send-key", Host, "29 56 111" | Arg]);

call(["define", File | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    Res = case file:read_file(File) of
        {ok, XML} ->
            vert:virDomainDefineXML(Connect, XML);
        Error ->
            Error
    end,
    rp(Res);

call(["destroy", Host | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    {ok, Domain} = domain(Connect, Host),
    rp(vert:virDomainDestroy(Domain));

call(["freecell" | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    rp(vert:virNodeGetFreeMemory(Connect));

call(["hostname" | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    rp(vert:virConnectGetHostname(Connect));

call(["list", "--all" | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    {ok, Shutoff} = vert:virConnectListDefinedDomains(Connect),
    {ok, Running} = domains(Connect, running),
    rp({ok, [{running, Running}, {shutoff, Shutoff}]});

call(["list" | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    Res = domains(Connect, running),
    rp(Res);

call(["read", Host, Timeout0]) ->
    Timeout = case Timeout0 of
        "infinity" -> infinity;
        _ -> list_to_integer(Timeout0)
    end,
    {ok, Ref} = vert_console:open(Host),
    Res = vert_console:read(Ref, Timeout),
    vert_console:close(Ref),
    rp(Res);

call(["read", Host]) ->
    call(["read", Host, "infinity"]);

call(["recv", Host, Timeout0]) ->
    Timeout = list_to_integer(Timeout0),
    {ok, Ref} = vert_console:open(Host),
    Res = vert_console:recv(Ref, Timeout),
    vert_console:close(Ref),
    rp(Res);

call(["screenshot", Host | Arg]) ->
    Opt = getopt(Arg),
    error_logger:info_report([{opt, Opt}]),
    Screen = proplists:get_value("screen", Opt, 0),
    File = proplists:get_value("file", Opt,
            Host ++ "_" ++ os:getpid() ++ ".screen"),

    {ok, Connect} = connect(Opt),
    {ok, Domain} = domain(Connect, Host),
    % XXX Put the stream in blocking mode. Seems to be the only way to
    % XXX read from a stream.
    {ok, Stream} = vert:virStreamNew(Connect, 0),
    {ok, Mime} = vert:virDomainScreenshot(Domain, Stream, Screen),

    error_logger:info_report([{mime, Mime}]),

    screenshot(Stream, File),

    {ok, Mime};

call(["send", Host | Commands]) ->
    {ok, Ref} = vert_console:open(Host, [{recv_timeout, 0}]),
    lists:foreach(fun(C) ->
            error_logger:info_report([{cmd, Host, C}]),
            ok = vert_console:send(Ref, C)
        end,
        Commands),
    rp(vert_console:close(Ref));

call(["send-key", Host, Keycode | Arg]) ->
    Opt = getopt(Arg),
    Codeset0 = proplists:get_value("codeset", Opt, "linux"),
    Holdtime = list_to_integer(proplists:get_value("holdtime", Opt, "0")),

    Codeset = try list_to_integer(Codeset0)
              catch
                _:_ -> list_to_atom(Codeset0)
              end,

    {ok, Connect} = connect(Opt),
    {ok, Domain} = domain(Connect, Host),

    rp(vert:virDomainSendKey(
                Domain,
                Codeset,
                Holdtime,
                [ list_to_integer(N) ||
                    N <- string:tokens(Keycode, " ") ]
                ));

call(["shutdown", Host | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    {ok, Domain} = domain(Connect, Host),
    rp(vert:virDomainShutdown(Domain));

call(["undefine", Host | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    {ok, Domain} = domain(Connect, Host),
    rp(vert:virDomainUndefine(Domain));

call(["uri" | Arg]) ->
    Opt = getopt(Arg),
    {ok, Connect} = connect(Opt),
    rp(vert:virConnectGetURI(Connect));

call(_) ->
    Help = [
        "capabilties",
        "ctl-alt-del",
        "console",
        "create",
        "define",
        "destroy",
        "freecell",
        "hostname",
        "list",
        "list --all",
        "read",
        "recv",
        "send",
        "shutdown",
        "undefine",
        "uri"
    ],
    rp(Help),
    halt(1).


%%-------------------------------------------------------------------------
%%% Internal functions
%%-------------------------------------------------------------------------
rp(Term) ->
    io:format("~p~n", [Term]).

getopt(Opts) ->
    getopt(Opts, []).
getopt([], Acc) ->
    lists:reverse(Acc);
getopt(["--" ++ Key, "--" ++ _ = Val | Rest], Acc) ->
    getopt([Val|Rest], [{Key, true}|Acc]);
getopt(["--" ++ Key, Val | Rest], Acc) ->
    getopt(Rest, [{Key, Val}|Acc]).

connect(Opt) ->
    URI = proplists:get_value("uri", Opt, "qemu:///system"),
    vert:virConnectOpen(URI).

domain(Connect, Host) ->
    Fun = [ fun() -> vert:virDomainLookupByID(Connect, list_to_integer(Host)) end,
            fun() -> vert:virDomainLookupByUUIDString(Connect, Host) end,
            fun() -> vert:virDomainLookupByName(Connect, Host) end ],
    domain_1(Fun).

domain_1(Fun)  ->
    domain_1(Fun, []).
domain_1([], [{error, Error}|_]) ->
    {error, Error};
domain_1([Fun|Tail], Acc) ->
    try Fun() of
        {ok, Domain} ->
            {ok, Domain};
        {error, Error} ->
            domain_1(Tail, [{error, Error}|Acc])
    catch
        _:_ ->
            domain_1(Tail, Acc)
    end.

console_output(Ref) ->
    {ok, Buf} = vert_console:read(Ref),
    io:fwrite(Buf),
    console_output(Ref).

console_input(Ref) ->
    Buf = io:get_chars("", 1),
%    error_logger:info_report([{in, Buf}]),
    ok = vert_console:write(Ref, Buf),
    console_input(Ref).

domains(Connect, running) ->
    case vert:virConnectListDomains(Connect) of
        {ok, Domains} -> {ok, id_to_name(Connect, Domains)};
        Error -> Error
    end.

id_to_name(Connect, Ids) when is_list(Ids) ->
    [ begin
        {ok, Domain} = vert:virDomainLookupByID(Connect, Id),
        {ok, Name} = vert:virDomainGetName(Domain),
        Name
      end || Id <- Ids ].

screenshot(Stream, File) ->
    screenshot(Stream, File, []).
screenshot(Stream, File, Acc) ->
    case vert:virStreamRecv(Stream, 16#FFFF) of
        {error, eagain} ->
            timer:sleep(100),
            screenshot(Stream, File, Acc);
        {ok, <<>>} ->
            ok = file:write_file(File, lists:reverse(Acc));
        {ok, Bytes} ->
            error_logger:info_report([{got, File, byte_size(Bytes)}]),
            screenshot(Stream, File, [Bytes|Acc])
        end.
